# 《C++  Primer中文版（第五版）》   第16章 模板与泛型编程

面向对象编程（OOP）和泛型编程能处理在编写时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。

当我们编写一个泛型程序时，是独立任何特性类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在上运行。

模板是泛型编程的基础。

#### 什么是泛型编程？

泛型编程是一种编程风格，其中算法以尽可能抽象的方式编写，而不依赖于将在其上执行这些算法的数据形式。

泛型编程是一种专注于对算法及其数据结构进行设计的编程方式，它使得这些算法即数据结构能够在不损失效率的前提下，运用到最为通用的环境中。

泛型这个词并不是通用的，在不同的语言实现中，具有不同的命名。在Java/Kotlin/C#中称为泛型（Generics），在ML/Scala/Haskell中称为Parametric Polymorphism，而在C++中被叫做模板（Template），比如最负盛名的C++中的STL。任何编程方法的发展一定是有其目的，泛型也不例外。泛型的主要目的是加强类型安全和减少强制转换的次数。

#### 什么是模板？

程序设计中经常会用到一些程序实体：它们的实现和所完成的功能基本相同，不同的仅 仅是所涉及的数据类型不同。而模板正是一种专门处理不同数据类型的机制。

人们需要编写多个形式和功能都相似的函数，因此有了函数模板来减少重复劳动；人们也需要编写多个形式和功能都相似的类，于是 [C++](http://m.biancheng.net/cplus/) 引人了类模板的概念，编译器从类模板可以自动生成多个类，避免了程序员的重复劳动。

一个模板就是一个创建类或函数的蓝图或者公式。

## 定义模板



### 函数模板

```cpp
template <模板参数列表> 返回类型 函数名(参数列表)
{
    函数体
}
```

模板参数列表：一个逗号分隔的一个或多个模板参数的列表

模板参数：模板参数表示在类或者函数定义中用到的类型或值。

注意事项：在模板定义中，模板参数列表不能为空

#### 实例化函数模板

​	直接像非函数模板那样调用。

​	编译器（通常）用函数实参来推断模板实参。

​	编译器用推断出的模板参数来实例化一个特定版本的函数。

#### 模板类型参数

​	一般来说可以把类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。

#### 非类型模板参数

​	可以在模板中定义非类型参数。一个非类型参数表示一个值而非一个类型。通过特定而非关键字class或typename来指定非类型参数。

​	当一个模板实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代。这些值必须是常量表达式。

模板程序应该尽量减少对实参类型的要求。

函数模板和类模板成员函数的定义通常放在头文件中。

模板直到实例化时才会生成代码。

保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。

### 类模板

```cpp
template<class  形参名，class 形参名，…>   class 类名
{ ... };
```

但是使用一个类模板时，我们必须提供额外的信息。这些额外信息时显式模板实参列表，它们被绑定到模板参数。

一个类模板的每个实例都形成一个独立的类。

在模板类外定义成员函数就必须以关键字template开始，后接类模板参数列表。

从一个模板生成的类的名字中必须包含其模板参数。

```cpp
template<typename T> ret-type classname<T>::memenber-name(param-list)
```

#### 类模板成员函数的实列化

​	默认情况下，一个类模板的成员函数只有当程序用到它时才进行实列化。

#### 在类代码中简化模板类名的使用

​	在类模板自己的作用域中，我们可以直接使用模板名而不提供实参

####  在类模板外使用类模板名

​	当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。

#### 类模板和友元

​	当一个类包含一个友元声明时，类与友元各自是否时模板是相互无关的。如果一个类包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定的实例。

#### 一对一友好关系

​	类模板与另一个（类或模板）模板间友好关系的最常见方式的形式是建立对应实例及其友元间的友好关系

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板本身。

友元声明用模板形参作为它们自己的模板参数。因此友好关系被限定在用相同类型实例化的友元和模板类之间。

#### 通用和特定的模板友好关系

一个类可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元。

```cpp
// 前置声明，在将模板的一个特定实例声明为友元时要用到
template<typename T>class Pal;
class C{ // C是一个普通的非模板类
    friend class Pal<C>; // 用类C实例化的pal是C的一个友元
    // pal2的所有实例都是C的友元；这种情况无须前置声明
    template<typename T>friend class Pal2;
}

template<typename T> class C3 { // C2本身是一个类模板
    // C2的每个实例将相同实例化的pal声明为友元
    friend  class Pal<T>;    // Pal的模板声明必须在作用域内
    // Pal2的所有实列都是C2每个实例的友元，不需要前置声明
    template<typename X> friend class Pal2;
    // Pal3是一个非模板类，它是C2所有实例的友元
    friend class Pal3;  //不需要Pal3的前置声明
}
```

为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数。

#### 令模板自己的类型参数成为友元

我们可以将模板类型参数声明为友元

```cpp
template <typename Type> class Bar{
    friend Type;   //将访问权限授予用来实例化Bar的类型
}
```

#### 模板类型别名

```cpp
//通过例子来体会
template<typename T> using twin = std::pair<T,T>;

//使用
twin<std::string> authors;  //authors是一个std::pair<std::string, std::string>
```

一个模板类型别名是一族类的别名。

当我们定义一个模板类型别名时，可以固定一个或 多个模板参数。

```cpp
template<typename T> using partNo = std::pair<std::string, unsigned>;
//这样在使用的时候就可以只传入一个类型参数
```

#### 类模板的static成员

类模板可以声明static成员。//声明方式与非模板类声明的方式相同

类模板的每个实例都有一个独有的static对象。将static数据成员定义成模板

```

```



```cpp
template <typename T>
class Foo
{
public:
    static std::size_t count() { return ctr; }

private:
    static std::size_t ctr;
};

// 将模板类的static数据成员定义成模板
template <typename T>
std::size_t Foo<T>::ctr = 0;

//要想使用模板类的静态成员，必须将实例化模板类
auto ct = Foo<int>::count();
```

### 模板参数

一个模板参数的名字没有什么内在含义，可以使用任何名字。通常使用T

#### 模板参数作用域

​	一个模板参数的可用范围是在其声明之后，至模板声明或定义结束之前。在模板内不能重用木一般参数名。

一个模板参数名在特定模板参数列表中只能出现一次。

#### 模板声明

​	模板声明必须包含模板参数

​	声明中的模板参数不必域定义中相同

​	一个给定模板的每个声明和定义必须具有相同数量和种类（类型或非类型）的参数。

```cpp
template<typename T> int compare(const T&, const T&);
template<typename T> class Blob;
```

#### 使用类的类型成员

​	默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。可以通过关键字typename来实现。

当我们希望通知编译器一个名字表示类型时，必须使用关键字typename,而不能使用class.

```cpp
template<typename T>
typename T::value_type top(const T& c)
{
    return typename T::value_type();
}

//这里的top希望一个容器类型的实参
```

#### 默认模板实参

可以提供默认模板实参

```cpp
template <class T, class F = std::less<T>>
int compare1(const T &v1, const T &v2, F f = F())
{
    if (f(v1, v2))
        return -1;
    if (f(v2, v1))
        return 1;
    return 0;
}
//调用方式和普通带默认实参的函数相同，当不给第三个参数时，使用的就是默认的less
```

#### 模板默认实参与类模板

无论何时使用给一个类模板，都必须在模板名之后接上尖括号。

如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一对空尖括号。

```cpp
template <class T = int>
class Numbers
{
public:
    Numbers(T v = 0) : val(v) {}

private:
    T val;
};

Numbers<double> aa;
Numbers<> a;
```

### 成员模板

一个类（无论是普通类还是类模板）可以包含本身时模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数。

#### 普通类（非模板）的成员模板

```cpp
// 普通类使用成员模板
class test1
{
public:
    test1(){};
    ~test1() = default;
    template <class T>
    T func(const T &t1, const T &t2)
    {
        return t1 + t2;
    }
};
std::cout << test1().func(23, 234) << std::endl; //普通类的成员模板调用方式
```

#### 类模板的成员模板

在类外定义一个成员模板时，必须同时提供类模板和成员模板参数列表。类蒙模板的参数列表在前，成员模板的参数列表在后。

```cpp
template <typename T>
class test2
{
public:
    test2(){};
    ~test2() = default;

    template <class T1>
    T1 func(const T1 &t1, const T1 &t2)
    {
        std::cout << "func " <<t1 + t2 << std::endl;
        return t1 + t2;
    }

    template <class u>
    u func2(const u &t1, const u &t2);
};

//类外定义
template <class T>
template <class u>
u test2<T>::func2(const u &t1, const u &t2)
{
    std::cout << "func2 " <<t1 + t2 << std::endl;
        return t1 + t2;
}

//使用方式
    test2<std::string> test3;
    test3.func(123,123);
    test3.func2(123,123);
    test2<int>().func(1234,1234);
    test2<int>().func2(1234,1234);
```



### 控制实列化

模板被使用时才会被实例化，为了避免在对各对象文件中出现相同的实例，通过显式实例化来避免这种情况。

```cpp
//格式：
	extern template declartion;  //实例化声明
	template declartion;		 //实例化定义
```

当编译器遇到extern模板声明时，他不会在本文件中生成实例化代码。将一个实列化声明为extern就表示承诺在其他位置有该实例化的一个非extern声明（定义）。

对于一个给定的实例化版本，可以有多个extern声明，但是必须只有一个定义。

由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用此实例化版本的代码之前。

对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

#### 实例化定义会实例化所有成员

​	一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。

​	原因：当编译器遇到实例化定义时，它不了解程序使用了哪些成员函数。因此编译器会实例化该类的所有成员。

  在一个类模板的实例化 定义中，所有类型必须能用于模板的所有成员函数。

### 效率与灵活性

## 模板实参推断

## 重载与模板

## 可变参数模板

## 模板特例化