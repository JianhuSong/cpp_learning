变量和基本类型
2.1 基本内置类型
	算术类型和空类型
算术类型：
	算术类型的尺寸在不同的机器上有所差别。 （尺寸就是所占位数）
	整型:有括号代表其有最小长度设定
	 bool 布尔类型   false/true  0/1
	 char 字符类型   最小尺寸8位
	 wchar_t 宽字符
	 char16_t Unicode 字符 16位
	 char32_t Unicode字符   32位
	 short    短整型        16位
	 int      整型          32位
	 long     长整型        32位
	 long long 长整型       64位
	 float      单精度      6位有效数字
	 double     双精度      10位有效数字
	 long double 扩展精度    10位有效数字
	浮点型：
空类型： void
	类型转换
		对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持
		，就是将对象从一种给定的类型转换为另外一种相关的类型。
		非布尔值变为布尔值，初始值为零就是false,否则为true
		布尔值付给非布尔类型时，初始值为false则为0，初始值为true为1.
		把浮点数赋值给整数类型时，进行了近似处理。结果值仅保存小数点前面的部分。
		整数类型赋值给浮点类型时，小数部分记为0.如果该整数所占的空间超过了浮点类型的
		容量，精度可能又损失。
		当我们赋给无辜好类型一个超出它表示范围的值时，结果时初始值对无符号类型表示数值总数取模后
		的余数。
		赋给带符号类型一个超出它表示范围的值时，结果是未定义的。
	字面值常量：
		每个字面值常量都对应一种数据类型，直勉之常量的形式和值决定了他的数据类型。
		尽管整型字面值可以存储在带有符号数据类型中，但是严格来说十进制的字面值不会是负数
		。负号的作用仅仅是对字面值取负值而已。
		默认的，浮点型字面值是一个double.
		由单引号括起来的一个字符称为char型字面值。
		双引号括起来的0个或多个字符构成字符串型字面值。
		字面值的前缀：
		u Unicode16字符 char16_t
		U Unicode32字符 char32_t
		L 宽字符 		wchar_t
		u8 UTF-8(仅用于字符串字面常量)  char
		
		整数类型字面值的后缀：
		u or U unsigned
		l or L long  
		ll or LL long long 
		
		浮点类型字面值的后缀:
		f/F   float
		l/L   long double
		
		布尔字面值和指针字面值
		true 和false 是布尔类型的字面值
		nullptr 是指针字面值
		
		
		2.2 变量
			变量是提供一个具名的、可供程序操作的存储空间。
			2.2.1 变量的定义
				变量定义的基本形式是：类型说明符，随后紧跟由一个或者多个变量名组成的列表。
			初始化：
				当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。
				可以是任意复杂的表达式
			列表初始化：
				无论是初始化对象还是某些时候为对象赋新值，都可以使用一组由花括号括起来的
				初始值了。
				int sold =0;
				int sold = {0};
				int sold{0};
				int sold(0);
			默认初始化：
				定义于任何函数体之外的变量被初始化为0；
				每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也是由类自己决定。
				
			2.2.2 变量声明和定义的关系
				变量声明规定了变量的类型和名字
				变量定义规定了变量的类型和名字，还为其申请了存储空间。
				任何包含了显式初始化的声明即成为了定义。
				变量能且只能被定义一次，但是声明可被多次声明。
			2.2.3 标识符
				语法规定的标识符定义格式：
				由字母、数字和下划线组成，其中必须以字母或者下划线开头。
				C++语言保留了一些标识符供其本身使用，这些名字不能用作标识符。
				
				C++标准库保留
				用户自定义的标识符中不能出现连续的两个下划线，也不能以下划线紧连大写字母开头。
				定义在函数体外的标识符不能以下划线开头。
				
				变量命名规范（约定俗成的，非语法规定）
				标识符要能体现实际含义
				变量名一般用小写字母
				用户自定义的类名一般以大写字母开头
				多个单词组成的标识符，单词间应有明显的区分。
				不按照这样做编译器不会报错，只是说程序的可读性可能没那么好。
			
			2.2.4 名字的作用域
				作用域时程序的一部分，C++语言中大多数作用域都以花括号分隔。
				同一个名字在不同的作用域中可能指向不同的实体。
				名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。
				当你第一次使用变量时再定义它。
				
				嵌套的作用域：
				允许再内层作用域中重新定义外层作用域已有的名字。
				对于全局变量和局部变量同名的情况。若局部变量正在作用域内那么就是时局部变量。
				大白话：作用域就近处理。
			
		2.3 复合类型
			复合类型是指基于其他类型定义的类型。
			一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。
			
			2.3.1 引用
				为对象起了另外一个名字，引用类型引用另外一种类型。
				int ival = 1024;
				int &refVal = ival;
				一般再初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用的时候，程序把
				引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将
				和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象上，因此
				引用必须初始化。
				
				引用即别名
					引用并非对象，相反的，他只是为一个已经存在的对象所起的另外一个名字。
			2.3.2 指针
				指针本身就是一个对象。
				在其生命周期内它可以先后指向几个不同的对象。
				指针无须在定义时赋初值。
				在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。。
				
				获取对象的地址
					使用“&” 取地址符。
				指针值
					指向一个对象
					指向紧邻对象所占空间的下一个位置。
					空指针，意味着指针没有指向任何对象。
					无效指针，也就是上述情况之外的其他值。
				建议：
					初始化所有指针。
					使用未经初始化的指针时引发运行时错误的一大原因。
			2.3.3 理解复合类型的声明
				变量的定义包括一个基本数据类型和一组声明符。
				一条定义语句肯能定义出不同类型的变量。
				int i = 1024, *p = &i, &r = i;
				指向指针的指针：
					一般来说，声明符中修饰符的哥数并没有限制。
					int ival = 1024；
					int *pi  = &ival;
					int **ppi = &pi;
				指向指针的引用：
					引用本身不是对象，所以不能定义指向引用的指针。
					int i = 42；
					int *p;
					int *&r = p;
					离变量最近的符号对变量的类型由最直接的影响。所以r是一个引用。
					面对一条比较复杂的指针或引用的声明语句时，从右往左阅读有助于弄清楚它的真是含义。
			2.4 const 限定符
				当我们希望定义一个值不能被改变的变量时，可以用关键字const对变量的类型加以限定。
				访问限制：
					默认状态下const对象仅在文件内有效。
					多文件共享const对象时，必须在变量的定义之前添加extern关键字。
			
				
遗留问题：
	1.浮点类型数据怎么比较大小？（由精度导致）
	 不能直接用"==" "!=" 来做比较，更具不同精度要求，可能结果有所不同。
	2.连续两个下划线的标识符是什么？
	 网上看了众多文章后，简单理解这些个标识符编译器可能用了，你再用可能有问题。建议最好别用。
	3.下划线紧连大写字母开头的标识符是什么？
	 同第二点
	4.函数体外以下划线开头的标识符是什么？
	 同第二点
	5.不是以花括号分隔作用域用的是什么？
	 这个暂时没有找到，工作中也没有遇到。
								