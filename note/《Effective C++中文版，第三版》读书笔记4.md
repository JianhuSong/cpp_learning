# 条款18：让接口容易被使用，不易被误用

从两个方面来实现这一原则：

**1.促进正确使用**

​	接口的一致性

​		很少有其它性质比得上“一致性”跟能导致“接口容易被正确使用”

​	与内置类型的行为兼容

​		除非有好理由，否则应该尽量令types的行为与内置types一致

**2.阻止误用**

​	建立新类型

​		明智而审慎地导入新类型对预防接口被误用有神奇疗效

​	限制类型上的操作

​		限制类型内什么事情可以做，什么事情不能做。常见的就是加上const

​	束缚对象值

​		限制对象的值处于一个合理的范围

​	消除客户的资源管理责任

​		任何接口如果要求客户必须记得做某些事情，就是有着“不正确使用”的倾向。

# 条款19：设计class犹如设计type

设计优秀的classes是一项艰巨的哦给你做，因为设计好的types是一项艰巨的工作：（初看懵懵懂懂，细看蒙蒙懂懂。）

**新type的对象应该如何被创建和销毁？**

​	影响class的构造函数和析构函数以及内存分配函数和释放函数

**对象的初始化和对象的赋值该有什么样的差别？**

​	决定构造函数和赋值操作符的行为，以及其间的差异

**新type的对象如果被passed by value,意味着什么？**

​	copy构造函数用来定义一个type的pass-by-value该如何实现

**什么是定义新type的合法值？**

​	对 class的成员变量而言，通常只有某些数值集是有效的。那些数值决定了你的class必须维护的约束条件，也就决定了你的成员函数（特别是构造函数、赋值操作符和所谓的setter函数）必须进行的错误检查工作。

**你的新type需要配合某个继承图系吗？**

​	继承于哪个class就受到哪个class的设计约束。如果让别人继承你的class会影响你声明的函数，特别是析构函数是否为virtual

**你的新 type需要什么样的转换？**

​	如果允许和别人转换，那么就应该提供转换功能函数.

**什么样的操作符和函数对此新type而言是合理的？**

​	这个决定了class需要声明哪些函数

**什么样的标准函数应该驳回？**

​	意思就是必须声明为private的

**谁该取用新type的成员？**

​	这个决定了成员的public/protect/private,以及哪一个class/function应该是friends,以及将它们嵌套于另一个之内是否合理

**什么是新type的未声明接口？**

​	它对效率、异常安全以及资源运用提供何种保证，这些个保证将为你的class实现代码上加上约束。

**你的新type有多么一般化？**

​	如果你的新type实际上是定义了一个types家族，那么请用class template

**你真的需要一个新的type?**

​	如果 定义新的derived class是为了为既有的class添加新的机能，定义一或多个non-member函数或templates,更能实现目标。



# 条款20：宁以pass-by-reference-to-const替换pass-by-value

原因：

​	by value方式，函数参数都是以实际参数的复件（副本）为初值，而调用端所获得的亦是返回值的一个复件。这些对象由copy构造函数产出，这可能使得pass-by-value成为昂贵的（费时的）操作

pass-by-reference-to-const 方式没有任何构造函数和析构函数被调用

对象切割：

​	当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数会被调用。从而导致其derived的特性被切割掉。

请记住：

​	尽量以pass-by-reference-to-const替换pass-by-value.前者通常比较高效，并可避免切割问题

​    对于内置类型和STL的迭代器和函数对象，pass-by-value比较何时。

# 条款21：必须返回对象时，别妄想返回其reference

一个必须返回对象的函数，那就让他返回一个对象。

# 条款22：将成员变量声明为private

将成员变量隐藏在函数接口后面，可以为“所有可能的实现”提供弹性。

public成员变量完全没有封装性，封装的重要性比你初见到它时还要重要。public意味着不封装，而几乎可以说不封装意味着不可改变。

重要知识点：

​	将成员变量声明为private

​	protected并不比public更具有封装性

# 条款23：宁以non-member、non-friend替换member函数

​	站在对象内的数据这个角度：

​		愈少数的代码可以看到数据，愈多的数据可以被封装，而我们也就能愈能自由地改变对象数据。

non-friend non-friend函数可以导致较大的封装性，因为它不能增加“能够访问class内的private成分”的函数数量。

关键知识：

​	宁可那non-member non-friend函数替换member函数，这样做可以增加封装性、包裹弹性和机能扩充性。

# 条款24：若所有参数皆需要类型转换，请为此采用non-member函数

如果需要为某个函数的所有参数（包括那些this指针所指的哪个隐喻参数）进行类型转换，那么这个函数必须是non-member

# 条款25：考虑些出一个不抛异常的swap函数

如果swap缺省实现的版的效率不足

1.提供一个public swqp成员函数，让它高效置换你的类型的两个对象值，这个函数不能抛异常

2.在class/template所在的命名空间中提供一个non-member swap,并令它调用上述swap成员函数。

3.如果你正编写一个class，为你的class特化一个std::swap.并令它调用你的swap成员函数

